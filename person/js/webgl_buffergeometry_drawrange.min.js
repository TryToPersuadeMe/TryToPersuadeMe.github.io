import*as THREE from"./js_plugins/three.module.js";let group,container,stats;const particlesData=[];let camera,scene,renderer,positions,colors,particles,pointCloud,particlePositions,linesMesh;const maxParticleCount=1e3;let particleCount=700;const r=window.innerWidth,rHalf=r/2,effectController={showDots:!0,showLines:!0,minDistance:85,limitConnections:!1,maxConnections:20,particleCount:500};function init(){container=document.getElementById("backgroundThreeJS"),camera=new THREE.PerspectiveCamera(45,window.innerWidth/window.innerHeight,1,2e3),camera.position.z=1750,scene=new THREE.Scene,group=new THREE.Group,scene.add(group);const e=new THREE.BoxHelper(new THREE.Mesh(new THREE.BoxGeometry(r,r,r)));e.material.color.setHex(1052688),e.material.blending=THREE.AdditiveBlending,e.material.transparent=!0,group.add(e);positions=new Float32Array(3e6),colors=new Float32Array(3e6);const t=new THREE.PointsMaterial({color:16777215,size:3,blending:THREE.AdditiveBlending,transparent:!0,sizeAttenuation:!1});particles=new THREE.BufferGeometry,particlePositions=new Float32Array(3e3);for(let e=0;e<1e3;e++){const t=Math.random()*r-r/2,i=Math.random()*r-r/2,n=Math.random()*r-r/2;particlePositions[3*e]=t,particlePositions[3*e+1]=i,particlePositions[3*e+2]=n,particlesData.push({velocity:new THREE.Vector3(2*Math.random()-1,2*Math.random()-1,2*Math.random()-1),numConnections:0})}particles.setDrawRange(0,particleCount),particles.setAttribute("position",new THREE.BufferAttribute(particlePositions,3).setUsage(THREE.DynamicDrawUsage)),pointCloud=new THREE.Points(particles,t),group.add(pointCloud);const i=new THREE.BufferGeometry;i.setAttribute("position",new THREE.BufferAttribute(positions,3).setUsage(THREE.DynamicDrawUsage)),i.setAttribute("color",new THREE.BufferAttribute(colors,3).setUsage(THREE.DynamicDrawUsage)),i.computeBoundingSphere(),i.setDrawRange(0,0);const n=new THREE.LineBasicMaterial({vertexColors:!0,blending:THREE.AdditiveBlending,transparent:!0});linesMesh=new THREE.LineSegments(i,n),group.add(linesMesh),renderer=new THREE.WebGLRenderer({antialias:!0}),renderer.setPixelRatio(window.devicePixelRatio),renderer.setSize(window.innerWidth,window.innerHeight),renderer.outputEncoding=THREE.sRGBEncoding,container.appendChild(renderer.domElement),window.addEventListener("resize",onWindowResize)}function onWindowResize(){camera.aspect=window.innerWidth/window.innerHeight,camera.updateProjectionMatrix(),renderer.setSize(window.innerWidth,window.innerHeight)}function animate(){let e=0,t=0,i=0;for(let e=0;e<particleCount;e++)particlesData[e].numConnections=0;for(let n=0;n<particleCount;n++){const o=particlesData[n];if(particlePositions[3*n]+=o.velocity.x,particlePositions[3*n+1]+=o.velocity.y,particlePositions[3*n+2]+=o.velocity.z,(particlePositions[3*n+1]<-rHalf||particlePositions[3*n+1]>rHalf)&&(o.velocity.y=-o.velocity.y),(particlePositions[3*n]<-rHalf||particlePositions[3*n]>rHalf)&&(o.velocity.x=-o.velocity.x),(particlePositions[3*n+2]<-rHalf||particlePositions[3*n+2]>rHalf)&&(o.velocity.z=-o.velocity.z),!(effectController.limitConnections&&o.numConnections>=effectController.maxConnections))for(let r=n+1;r<particleCount;r++){const s=particlesData[r];if(effectController.limitConnections&&s.numConnections>=effectController.maxConnections)continue;const a=particlePositions[3*n]-particlePositions[3*r],c=particlePositions[3*n+1]-particlePositions[3*r+1],l=particlePositions[3*n+2]-particlePositions[3*r+2],p=Math.sqrt(a*a+c*c+l*l);if(p<effectController.minDistance){o.numConnections++,s.numConnections++;const a=1-p/effectController.minDistance;positions[e++]=particlePositions[3*n],positions[e++]=particlePositions[3*n+1],positions[e++]=particlePositions[3*n+2],positions[e++]=particlePositions[3*r],positions[e++]=particlePositions[3*r+1],positions[e++]=particlePositions[3*r+2],colors[t++]=a,colors[t++]=a,colors[t++]=a,colors[t++]=a,colors[t++]=a,colors[t++]=a,i++}}}linesMesh.geometry.setDrawRange(0,2*i),linesMesh.geometry.attributes.position.needsUpdate=!0,linesMesh.geometry.attributes.color.needsUpdate=!0,pointCloud.geometry.attributes.position.needsUpdate=!0,requestAnimationFrame(animate),render()}function render(){const e=.001*Date.now();group.rotation.y=.1*e,renderer.render(scene,camera)}init(),animate();